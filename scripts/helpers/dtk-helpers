# This file is to be sourced by the root dtk script so that script is less busy.

#
# Enables scripts to exec other scripts by name only or pathpart/name.
#
function xec() {
  if echo $1 | grep -q /; then
    f=$(find $DTKBASE/scripts -type d -name $(dirname $1) | xargs -I% find % -type f -name $(basename $1))
  else
    f=$(find $DTKBASE/scripts -name $1)
  fi
  [[ -n $f ]] && $f "${@:2}"
}
export -f xec

#
# Translates "true" to 1 and "false" to 0. The function arg is a variable
# name, whose contents may be modified by the function. Returns a non-zero
# exit code on error, else a zero exit code.
#
function xlat_tf() {
    local -n var_ref=$1
    if [[ -z "$var_ref" ]] || [[ $var_ref == "1" ]] || [[ $var_ref == "0" ]] then
      return
    elif [[ $var_ref == "true" ]]; then
      var_ref=1
    elif [[ $var_ref == "false" ]]; then
      var_ref=0
    else
      false
      return
    fi
    true
}

#
# Verifies the dirname pased in $1 matches a directory name under
# scripts/addons.
#
function validate_addon() {
  while read dirname; do
    if [[ $1 == $dirname ]]; then
      true
      return
    fi
  done < <(find $DTKBASE/scripts/addons -maxdepth 1 -mindepth 1 -type d -printf "%f\n")
  false
}

#
# Parses the command line.
#
function parse_cmdline() {
  if [[ "$#" -eq 0 ]]; then
    echo "no args specified, try: ./dtk help (the command line was re-designed in version v1.34.1-1)"
    exit 1
  fi

  parse_error=
  for ((i=1; i<=$#; i++)); do
    arg="${!i}"
    case $arg in
      cluster|verify)
        ((i++))
        if [[ -z "${!i}" ]]; then
          parse_error=1
          break
        fi
        operation="$arg-${!i}"
        ;;
      install-addon)
        ((i++))
        if [[ -z "${!i}" ]]; then
          parse_error=1
          break
        fi
        operation="$arg"
        addon="${!i}"
        ;;
      check-tools)
        operation="$arg"
        ;;
      --config=*)
        config=$(echo $arg | cut -d= -f2)
        ;;
      --config)
        ((i++))
        if [[ -z "${!i}" ]]; then
          parse_error=1
          break
        fi
        config="${!i}"
        ;;
      --create-template=*)
        create_template=$(echo $arg | cut -d= -f2)
        ;;
      --create-template)
        ((i++))
        if [[ -z "${!i}" ]]; then
          parse_error=1
          break
        fi
        create_template="${!i}"
        ;;
      --create-vms=*)
        create_vms=$(echo $arg | cut -d= -f2)
        ;;
      --create-vms)
        ((i++))
        if [[ -z "${!i}" ]]; then
          parse_error=1
          break
        fi
        create_vms="${!i}"
        ;;
      version)
        operation="version"
        ;;
      help|--help)
        operation="help"
        ;;
      *)  
        parse_error=1
        ;;
    esac
  done

  xlat_tf create_template || parse_error=1
  xlat_tf create_vms || parse_error=1

  if [[ "$parse_error" -eq 1 ]]; then
    echo "unable to parse command line, try: ./dtk help (the command line was re-designed in version v1.34.1-1)"
    exit 1
  fi

  valid_ops=(".cluster-create." ".cluster-delete." ".cluster-up." ".cluster-down." ".install-addon."
  ".verify-upstreams." ".verify-files." ".check-tools." ".version." ".help.")
  if [[ ! ${valid_ops[@]} =~ ".$operation." ]]; then
    echo "unknown operation '$operation', try: ./dtk help (the command line was re-designed in version v1.34.1-1)"
    exit 1
  fi

  if [[ -n "$addon" ]]; then
    if ! validate_addon $addon; then
      echo "unknown addon: '$addon', try: ./dtk help (the command line was re-designed in version v1.34.1-1)"
      exit 1
    fi
  fi
}

#
# Validates the config.yaml file.
#
function validate_config_file() {
  config=$(realpath $config)
  if [[ ! -f "$config" ]]; then
    echo "config file not found: $config"
    exit 1
  fi
  scripts/helpers/parse-config.py $config check || exit
}

#
# Allows the cmdline to override config.yaml.
#
function set_cmdline_overrides() {
  case $create_template in
    1)
      vm_create_template=1
      ;;
    0)
      vm_create_template=0
      ;;
  esac
}

#
# Performs configuration validation and in some cases performs configuration overrides
# (e.g., for omitted values.)
#
function validate_config_values() {
  supported_linux=(".centos9." ".rocky." ".alma8." ".alma9.")
  if [[ ! ${supported_linux[@]} =~ ".$vm_linux." ]]; then
    echo "unsupported value for linux config: $vm_linux"
    exit 1
  fi

  if [[ $virt == "virtualbox" ]]; then
    if [[ -z "$vbox_host_network_interface" ]] && [[ -z "$vbox_host_only_network" ]]; then
      echo "either --host-network-interface or --host-only-network is required"
      exit 1
    elif [[ ! -z "$vbox_host_network_interface" ]] && [[ ! -z "$vbox_host_only_network" ]]; then
      echo "--host-network-interface and --host-only-network are exclusive of each other"
      exit 1
    fi
    if [[ -z "$vbox_vboxdir" ]]; then
      vbox_vboxdir=$(vboxmanage list systemproperties | grep folder | awk -F: '{print $2}' | xargs)
    fi
    if [[ -z "$vbox_vboxdir" ]]; then
      echo "directory for virtualbox VMs is not defined"
      exit 1
    elif [[ ! -d $vbox_vboxdir ]]; then
      echo "directory for virtualbox VMs does not exist: $vbox_vboxdir"
      exit 1
    fi
  fi
}
